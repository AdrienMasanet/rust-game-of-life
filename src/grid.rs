use crate::cell::Cell;
use crate::{CELL_COUNT_START, CELL_SIZE_AS_F32, GRID_HEIGHT, GRID_WIDTH};
use macroquad::prelude::*;
use std::collections::HashMap;

pub struct Grid {
    cells_width: i32,  // Number of cells in the grid width
    cells_height: i32, // Number of cells in the grid height
    cells: HashMap<(i32, i32), Cell>,
}

impl Grid {
    pub fn new() -> Grid {
        return Grid {
            cells_width: GRID_WIDTH,
            cells_height: GRID_HEIGHT,
            cells: HashMap::new(),
        };
    }

    pub fn populate_cells(&mut self) {
        // Panic if the number of cells is greater than the grid size which would cause an out of bounds error
        if CELL_COUNT_START >= self.cells_width as usize * self.cells_height as usize {
            panic!("The number of cells to start with is too high. For a grid of {}x{} cells, the maximum number of cells to start with is {}", GRID_WIDTH, GRID_HEIGHT, GRID_WIDTH * GRID_HEIGHT);
        }

        println!("Populating the grid with {} cells...", CELL_COUNT_START);
        for x in 0..self.cells_width {
            for y in 0..self.cells_height {
                println!("Creating cell at x: {}, y: {}", x, y);
                self.cells.insert((x, y), Cell::new(x, y, false, false));
            }
        }

        println!("Grid populated with {} cells", self.cells.len());
        println!("Making {} cells alive", CELL_COUNT_START);

        let mut cells_left_to_make_alive: usize = CELL_COUNT_START;

        while cells_left_to_make_alive > 0 {
            // Generate a random x and y position for the cell
            let x: i32 = rand::gen_range(0, GRID_WIDTH);
            let y: i32 = rand::gen_range(0, GRID_HEIGHT);

            // Get the cell at the random position that was generated by getting the value of the key (x, y) in the cells HashMap
            let mut cell_to_make_alive: &mut Cell = self.cells.get_mut(&(x, y)).unwrap();

            // Check if the cell is already alive
            if !cell_to_make_alive.alive {
                // If the cell is not in the vector, add it to the vector
                cell_to_make_alive.alive = true;
                cell_to_make_alive.will_live = true;
                cells_left_to_make_alive -= 1;
                println!(
                    "Making cell at x: {}, y: {} alive. {} cells left to make alive",
                    cell_to_make_alive.x, cell_to_make_alive.y, cells_left_to_make_alive
                );
            }
        }

        println!("{} cells have been made alive", CELL_COUNT_START);
    }

    pub fn update(&mut self) {
        // Iterate through each cell of the grid
        for x in 0..self.cells_width {
            for y in 0..self.cells_height {
                let mut cell: &mut Cell = self.cells.get_mut(&(x, y)).unwrap();

                cell.alive = cell.will_live;

                // Draw the cell
                if cell.alive {
                    draw_rectangle(
                        cell.x as f32 * CELL_SIZE_AS_F32,
                        cell.y as f32 * CELL_SIZE_AS_F32,
                        CELL_SIZE_AS_F32,
                        CELL_SIZE_AS_F32,
                        WHITE,
                    );
                }

                //let cell_apply_rules_start_time = Instant::now(); // Start the timer for the cell rules logic

                let alive_neighbors: u8 = self.count_alive_neighbors(x, y); // Count cell neighbors that are alive

                let mut cell: &mut Cell = self.cells.get_mut(&(x, y)).unwrap(); // We borrow the cell again because we can't borrow it twice at the same time

                // Apply the rules of the game of life
                if alive_neighbors == 3 {
                    // If the cell has 3 alive neighbors, it will live
                    cell.will_live = true;
                } else if alive_neighbors < 2 || alive_neighbors > 3 {
                    // If the cell has less than 2 or more than 3 alive neighbors, it will die
                    cell.will_live = false;
                }
            }
        }
    }

    fn count_alive_neighbors(&self, cell_x: i32, cell_y: i32) -> u8 {
        let mut alive_neighbors: u8 = 0;

        // Check the neighbors of the cell
        for x in -1..=1 {
            for y in -1..=1 {
                // Check if the neighbor is the cell itself
                if x == 0 && y == 0 {
                    continue;
                }

                // Check if the neighbor is alive
                if let Some(neighbor) = self.cells.get(&(cell_x + x, cell_y + y)) {
                    if neighbor.alive {
                        alive_neighbors += 1;
                    }
                }
            }
        }

        return alive_neighbors;
    }
}
